{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts/basic-git-usage/","result":{"data":{"site":{"siteMetadata":{"title":"Dave's Blog","author":"Dave Kelly","blogPrefix":"posts"}},"markdownRemark":{"id":"d1475cc4-b0ee-5d55-a9d5-c7b5883e3bb6","excerpt":"Git is a powerful tool for managing multiple revisions of a codebase. As you make changes to files within a codebase, you might be tempted to make backup copies…","html":"<p>Git is a powerful tool for managing multiple revisions of a codebase. As you make changes to files within a codebase, you might be tempted to make backup copies of your code in case you break something and want to revert to a working version:</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">index.html\nindex-final(v2).html\nindex-backup1.html\nindex-backup2.html</code></pre></div>\n<p>We want to avoid this! It’s messy and doesn’t scale as you end up with a codebase that has potentially hundreds of files.</p>\n<p>That’s where Git comes in. Git gives us the ability to set checkpoints called “commits” for our codebase that we can revert to if needed. We can also share these commits across different machines. Git also gives us the ability to merge changes between multiple commits into a new commit. This makes it a powerful collaboration tool and allows us to quickly switch tasks if we need to make multiple changes at once. For example, we might be working on a new feature for our web application when a critical bug is reported that needs to be fixed ASAP. Rather than backing out all our work on the new feature, or rushing to finish the new feature, we can save our feature work to a commit, then go back to the previous commit, fix the bug with a new commit, then merge the fix into our feature work so we don’t write over it as we make new changes.</p>\n<p>Let’s get started!</p>\n<p>Make a new directory for our web application: <code class=\"language-text\">mkdir -p ~/Source/webapp</code></p>\n<p>Change into the app directory: <code class=\"language-text\">cd ~/Source/webapp</code></p>\n<p>Initialize a new Git repository</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ webapp git init\nInitialized empty Git repository in /Users/dan/Source/webapp/.git/</code></pre></div>\n<p>Git will now track changes to files within the webapp repository. It created a hidden directory <code class=\"language-text\">.git</code> within our project directory where it will keep track of commits and general configuration for the project. Since it’s just a directory and files, you can open the <code class=\"language-text\">.git</code> directory and look around. Be careful about making any changes! In practice, you likely won’t be directly modifying anything in this directory yourself.</p>\n<p>Back in our <code class=\"language-text\">webapp</code> directory, let’s open VSCode and start making some edits: <code class=\"language-text\">code .</code> Opens VSCode in the current directory.</p>\n<p>Create a new file in VSCode called <code class=\"language-text\">README.md</code>. We’ll use this to convey any important information about our webapp project. Write a few sentences to describe the new project. The <code class=\"language-text\">md</code> file extension indicates that this is a markdown file. Markdown is a file format that is meant to be human readable text, but uses special characters to denote special meaning:</p>\n<ul>\n<li>Lines starting with <code class=\"language-text\">#</code> are treated as top-level headings</li>\n<li>Lines starting with <code class=\"language-text\">##</code> are treated as secondary headings</li>\n<li>Text surrounded by a single underscore is emphasized: <code class=\"language-text\">_text to emphasize_</code></li>\n<li>Text surrounded by two underscores is strongly emphasized: <code class=\"language-text\">__strongly__ emphasized</code></li>\n<li>Links to URLs can be embedded: <code class=\"language-text\">[link text](https://url-to-content.com)</code></li>\n</ul>\n<p>For now, let’s add the following text to our README.md file:</p>\n<div class=\"gatsby-highlight\" data-language=\"markdown\"><pre class=\"language-markdown\"><code class=\"language-markdown\"><span class=\"token title important\"><span class=\"token punctuation\">#</span> My First Web Application</span>\n\nThis repository contains the code for my first web application.</code></pre></div>\n<p>Save the file and switch back to iterm2.</p>\n<p>Git can tell us of any high level file changes with <code class=\"language-text\">git status</code></p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ git status\nOn branch main\n\nNo commits yet\n\nUntracked files:\n  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)\n\tREADME.md\n\nnothing added to commit but untracked files present (use &quot;git add&quot; to track)</code></pre></div>\n<p>This gives us a quick overview of the state of our repository. We’re currently using the <code class=\"language-text\">main</code> branch and have not created any checkpoints or commits yet in this repository. Git identified a new file <code class=\"language-text\">README.md</code> that is considered “untracked” because it hasn’t been included in any commits yet.</p>\n<p>Let’s create our first commit and start tracking changes for the README.md file:</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ git add README.md\n$ git commit -m &quot;Initial readme file&quot;\n[main (root-commit) 0388158] Initial readme file\n 1 file changed, 3 insertions(+)\n create mode 100644 README.md</code></pre></div>\n<p><code class=\"language-text\">git add README.md</code> tells git to start tracking changes made to the README.md file. <code class=\"language-text\">git add</code> can take any path within the repository. In practice, you might find youself using <code class=\"language-text\">git add .</code> to track changes to all files in the repository.</p>\n<p><code class=\"language-text\">git commit -m &quot;Initial readme file&quot;</code> tells git to create a new commit or checkpoint for the state of all files that are currently tracked in the repository. The commit accepts a message that we provide with the <code class=\"language-text\">-m</code> flag. This message is used to give ourselves context about what changes were made in the commit. Over time, we can use these messages to see a history of our progress in developing the app.</p>\n<p>The output from the commit tells us that the commit was applied to the <code class=\"language-text\">main</code> branch. It also includes a hash of the changes (<code class=\"language-text\">0388158</code> in the example output) and the commit message. Below the message, the output gives a summary of the changes that were committed.</p>\n<h2>What is a branch in Git?</h2>\n<p>Our <code class=\"language-text\">git status</code> command above just told us we’re currently on the <code class=\"language-text\">main</code> branch, but what does this actually mean? If we think about how we’ll be making changes to our codebase, we could be working on multiple features and bug fixes in parallel at any given time. We want to work on each change independently of the other changes however. In the example scenario at the beginning of this post, we described using multiple commits for different changes. What if we wanted to use more than one checkpoint when developing a feature? It’s a good practice to commit often. Think of it like setting a checkpoint in a video game. If things get messy, you can safely return to the checkpoint. Branches allow us to separate our work in progress by feature. We can create multiple commits on a given branch, then merge the feature branch into the main branch when it’s done to apply changes from all of the commits of that branch.</p>\n<p>Let’s create a new branch to add a <a href=\"https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners\">CODEOWNERS</a> file. The <code class=\"language-text\">CODEOWNERS</code> file is used to identify the maintains of the code in the repository. This is helpful for providing contact information of subject matter experts in larger organizations where the maintainers of the codebase might not always be immediately known by everyone.</p>\n<p>First, let’s make a new branch for this change. It’s important not to work on changes directly on the <code class=\"language-text\">main</code> branch (this defeats the purpose)! <code class=\"language-text\">git checkout -b add-codeowners</code></p>\n<p>The <code class=\"language-text\">git checkout</code> command is used for switching to different commits. We can specify commits to <code class=\"language-text\">git checkout</code> in a few different ways:</p>\n<ul>\n<li>Use the name of a branch like <code class=\"language-text\">git checkout main</code> (most common)</li>\n<li>Use a commit hash <code class=\"language-text\">git checkout 0388158</code></li>\n<li>\n<p>Relative to the history</p>\n<ul>\n<li><code class=\"language-text\">git checkout HEAD</code> (checkout the latest commit)</li>\n<li><code class=\"language-text\">git checkout HEAD~1</code> (checkout the commit before the latest commit)</li>\n</ul>\n</li>\n</ul>\n<p>Our use of the <code class=\"language-text\">-b</code> flag tells <code class=\"language-text\">git checkout</code> to switch to a new branch off of our current repository state named <code class=\"language-text\">add-codeowners</code>. The <code class=\"language-text\">checkout</code> command does not create any commits!</p>\n<p>Add the following to the CODEOWNERS file, substituting your email address for the sample email below:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">* your@email.com</code></pre></div>\n<p>While we’re editing files in VSCode, let’s add the following note to the bottom of our README.md file to help collaborators navigate our repository:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Maintainers are listed in the CODEOWNERS file.</code></pre></div>\n<p>Save your changes and return to iterm.</p>\n<p>Let’s get our bearings with <code class=\"language-text\">git branch</code>. This lists the available branches in the repository and indicates the current branch.</p>\n<p>Let’s check on our outstanding changes with <code class=\"language-text\">git status</code>. At this point, it identifies that we’ve made changes to our README.md file and have also added a new CODEOWNERS file.</p>\n<p>Use <code class=\"language-text\">git diff</code> to show all outstanding changes in files that are already tracked. The new line that we added to the readme should be listed in the diff. The <code class=\"language-text\">+</code> at the beginning of the line indicates that the line will be added to the file (a leading <code class=\"language-text\">-</code> would indicate the line will be removed). Note that changes in the CODEOWNERS file aren’t listed in the diff. This is because the CODEOWNERS file hasn’t yet been added for tracking.</p>\n<p>Use the <code class=\"language-text\">git add</code> command to add the changes to both files. Do you remember how to do this in one command?</p>\n<p>If you’ve successfully added both files to tracking, you should see the following when running the <code class=\"language-text\">git status</code> command</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ git status\nOn branch add-codeowners\nChanges to be committed:\n  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)\n\tnew file:   CODEOWNERS\n\tmodified:   README.md</code></pre></div>\n<p>We still don’t have a new checkpoint yet, let’s create the checkpoint now: <code class=\"language-text\">git commit -m &quot;Add CODEOWNERS&quot;</code>.</p>\n<p>Now that we have a commit saved, let’s go back to our <code class=\"language-text\">main</code> branch and make another change. Use the <code class=\"language-text\">git checkout</code> command to switch toe the <code class=\"language-text\">main</code> branch (hint: the exact command is mentioned earlier in this post).</p>\n<p>We can confirm that we switched to the <code class=\"language-text\">main</code> branch using the <code class=\"language-text\">git branch</code> command.</p>\n<p>Checkout a new branch called <code class=\"language-text\">add-changelog</code> (hint: we used the command to checkout a new branch earlier when we made a change to add the CODEOWNERS file). Confirm that we have switched to the new branch using the <code class=\"language-text\">git branch</code> command.</p>\n<p>Make a new file called CHANGELOG.md and add the following to it:</p>\n<div class=\"gatsby-highlight\" data-language=\"markdown\"><pre class=\"language-markdown\"><code class=\"language-markdown\"><span class=\"token list punctuation\">-</span> Added CHANGELOG</code></pre></div>\n<p>Add the following line of text to the bottom of the README.md file:</p>\n<div class=\"gatsby-highlight\" data-language=\"markdown\"><pre class=\"language-markdown\"><code class=\"language-markdown\">Changes are tracked using the CHANGELOG</code></pre></div>\n<p><em>Note:</em> Best practices for maintaining a changelog would use the <a href=\"https://keepachangelog.com/\">keep a changelog</a> approach, but we just need something lightweight for this exercise.</p>\n<p><code class=\"language-text\">git add</code> the changes to tracking and commit the changes with a meaningful commit message.</p>\n<p>After adding and committing the changes, <code class=\"language-text\">git status</code> should report that there are no outstanding changes:</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ git status\nOn branch add-changelog\nnothing to commit, working tree clean</code></pre></div>\n<p>We’ve made two distinct changes so far, but at this point these changes are on separate feature branches. We can access each change by switching to the respective branch, but now that our changes are complete, we want them all to be applied on the <code class=\"language-text\">main</code> branch.</p>\n<p>Let’s merge the first change into the <code class=\"language-text\">main</code> branch. First switch to the <code class=\"language-text\">main</code> branch.</p>\n<p>From the <code class=\"language-text\">main</code> branch, merge changes from our codeowners branch: <code class=\"language-text\">git merge add-codeowners</code></p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ git merge add-codeowners\nUpdating 0388158..5f899ef\nFast-forward\n CODEOWNERS | 1 +\n README.md  | 2 ++\n 2 files changed, 3 insertions(+)\n create mode 100644 CODEOWNERS</code></pre></div>\n<p>The command output shows which changes are applied.</p>\n<p>Now let’s merge our changes to add a changelog into the <code class=\"language-text\">main</code> branch:</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ git merge add-changelog\nAuto-merging README.md\nCONFLICT (content): Merge conflict in README.md\nAutomatic merge failed; fix conflicts and then commit the result</code></pre></div>\n<p>This output doesn’t show our changes being applied. What happened?!</p>\n<p>We’ve encountered a merge conflict! Git wasn’t able to automatically apply the changes we made in the README.md file because we made different changes in the same place in README.md file in two parallel branches. Git needs our help to determine how to handle these conflicting changes. In this case, we only have a conflict in the README.md file, but when merging larger changes, we could have conflicts in many files. Git will list every file with conflicts here. We need to resolve each conflict before finishing the merge.</p>\n<p>Open the README.md file in VSCode and notice that Git has altered the file to indicate the conflicts:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># My First Web Application\n\nThis repository contains the code for my first web application.\n\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\nMaintainers are listed in the CODEOWNERS file.\n=======\nChanges are tracked in the changelog\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; add-changelog</code></pre></div>\n<p>We need to edit this file to remove any conflicts. In this case, we want to keep both changes, so we can safely remove the text added by Git. Our README should look something like this now:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># My First Web Application\n\nThis repository contains the code for my first web application.\n\nMaintainers are listed in the CODEOWNERS file.\n\nChanges are tracked in the changelog</code></pre></div>\n<p><code class=\"language-text\">git status</code> tells us that we still have some outstanding changes:</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ git status\nOn branch main\nYou have unmerged paths.\n  (fix conflicts and run &quot;git commit&quot;)\n  (use &quot;git merge --abort&quot; to abort the merge)\n\nChanges to be committed:\n\tnew file:   CHANGELOG.md\n\nUnmerged paths:\n  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)\n\tboth modified:   README.md</code></pre></div>\n<p>We need to add and commit our change to resolve the conflict:</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ git add README.md\n$ git commit -m &quot;Merge branch add-changelog into main&quot;</code></pre></div>\n<p>We can use <code class=\"language-text\">git log</code> to open the revision history for the repository.</p>\n<p>Now that our changes have been merged, we no longer need to maintain a reference to the feature branches. Let’s do some cleanup by deleting our feature branches.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ git branch -d add-changelog\nDeleted branch add-changelog (was abb0af6).\n$ git branch -d add-codeowners\nDeleted branch add-codeowners (was 5f899ef).</code></pre></div>\n<p>Create a new repository in GitHub. Do not choose the option to initialize with a readme, since we’ve already initialized our repository in this exercise. Copy the command that GitHub provides to add the remote repository.</p>\n<p>Push our changes to GitHub with <code class=\"language-text\">git push</code>.</p>\n<p>Git supports hooks that we can tap into as a way of executing commands during certain events. Later on, we can tap into these hooks to automatically run tests to make sure our changes are working correctly and then deploy the changes to a server if everything looks good.</p>","frontmatter":{"title":"Learn Basic Git usage","date":"December 18, 2022","description":"The most common commands for a successful git workflow"}}},"pageContext":{"slug":"/basic-git-usage/","previous":{"fields":{"slug":"/basic-shell-commands/"},"frontmatter":{"title":"Learn Basic Shell Commands"}},"next":null}}}