{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts/basic-shell-commands/","result":{"data":{"site":{"siteMetadata":{"title":"Dave's Blog","author":"Dave Kelly","blogPrefix":"posts"}},"markdownRemark":{"id":"91b8780f-f70f-53f0-b0f2-516348f59004","excerpt":"Prereq: install iTerm2\nPrereq: install VSCode Open iterm2 and try out a few commands: When you open iterm2, it creates a new instance of a shell where you’ll be…","html":"<p><em>Prereq</em>: install <a href=\"https://iterm2.com/\">iTerm2</a>\n<em>Prereq</em>: install <a href=\"https://code.visualstudio.com/\">VSCode</a></p>\n<p>Open iterm2 and try out a few commands:</p>\n<p>When you open iterm2, it creates a new instance of a shell where you’ll be able to run commands. The shell is responsible for accepting your input from the keyboard, interpretting that input, executing the appropriate commands based on your input, and surfacing any output from those commands.</p>\n<p><code class=\"language-text\">echo</code> prints its arguments to standard output. When you enter <code class=\"language-text\">echo hello world</code> on the command line, the first “token”, <code class=\"language-text\">echo</code> is the name of the command to execute. In a shell, tokens are separated by whitespace. Additional tokens are called “arguments” and can be used to control the behavior of the command. “Standard output” refers to the destination where commands can write feedback on their execution. In this case, it’s written back to the shell in your terminal. Type <code class=\"language-text\">echo hello world</code> and press enter:</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ echo hello world\nhello world</code></pre></div>\n<p><em>Note:</em> in the sample above, the <code class=\"language-text\">$</code> is meant to indicate your command prompt. Lines starting with a <code class=\"language-text\">$</code> in a code block means that is a command that you type. Lines that don’t start with a <code class=\"language-text\">$</code> indicate output from a command. In practice, your prompt may look different than a <code class=\"language-text\">$</code>. It’s common for the prompt to include your username, the current directory, the name of your machine, or some combination of all three.</p>\n<p><code class=\"language-text\">pwd</code> print the absolute path of the current directory.</p>\n<p><code class=\"language-text\">cd</code> change directory to the specified path. If no path is specified, navigates to your home directory. A path can be specified to this command as a command line argument. For example: <code class=\"language-text\">cd mydir</code>.</p>\n<p>Note about paths: <em>Absolute paths</em> always resolve to the same resource regardless of where you are when referencing the path. <em>Relative paths</em> resolve to the resource based on where you currently are.</p>\n<p>Consider the following directory structure</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">/\n  Users\n    dan\n      Desktop\n      Documents\n        project1\n        project2\n        my project</code></pre></div>\n<p>If you are currently in your home directory <code class=\"language-text\">/Users/dan</code>, and want to navigate to the <code class=\"language-text\">project1</code> directory, you could take multiple approaches:</p>\n<ul>\n<li>Absolute path: <code class=\"language-text\">cd /Users/dan/Documents/project1</code> — This has the benefit of working from any current working directory, but can also be a lot to type depending on the path</li>\n<li>Relative path: <code class=\"language-text\">cd Documents/project1</code> — This is more concise, but requires you to know how to get to the directory from where you currently are</li>\n</ul>\n<p>There are a couple special “paths”:</p>\n<ul>\n<li><code class=\"language-text\">/</code> root directory - Think of your filesystem like a tree: all files in your filesystem are connected to the root directory through one or more parent directories</li>\n<li><code class=\"language-text\">.</code> current directory — This can be useful for relative paths: <code class=\"language-text\">cd ./Documents/project1</code> is equivalent to <code class=\"language-text\">cd Documents/project1</code></li>\n<li>\n<p><code class=\"language-text\">..</code> parent directory - This is important in traversing closer to the root directory:</p>\n<ul>\n<li>Try <code class=\"language-text\">cd ..</code> — Use <code class=\"language-text\">pwd</code> to confirm which directory you are now in</li>\n<li>You can chain these together to ascend multiple levels at once: Try <code class=\"language-text\">cd ../..</code></li>\n</ul>\n</li>\n<li><code class=\"language-text\">~</code> home directory — This is a reference to your user’s directory. If your username is <code class=\"language-text\">dan</code>, the command <code class=\"language-text\">cd ~</code> will navigate to <code class=\"language-text\">/Users/dan</code></li>\n</ul>\n<p>Question: What are three different ways to change to the home directory?</p>\n<p>Try to navigate to a directory with a space in the name: For example: <code class=\"language-text\">cd Documents/my project</code>\nNormally, we’d expect to not see much feedback from the cd command. For most shell commans, <em>no news is good news</em>. If you don’t see any feedback in your terminal, it usually means things are working correctly. In this case however, you might get an error!</p>\n<p>Remember: the shell uses whitespace to separate arguments for the cd command. Our directory has a space in the name so when we specify the directory, the shell treats it as two arguments. We need to “escape” the space in the name to tell the shell that the space is part of the same argument. We use the backslash <code class=\"language-text\">\\</code> to escape special characters: <code class=\"language-text\">cd Documents/my\\ project</code></p>\n<p><code class=\"language-text\">ls</code> Lists the contents of a directory. Without any arguments, will list both files and directories in the current directory. Use <code class=\"language-text\">cd</code> to navigate to a different directory, then type <code class=\"language-text\">ls</code> to list that directory’s contents. <code class=\"language-text\">ls</code> also accepts a path to a directory as an argument. This allows you to list the contents of any directory in a single command without <code class=\"language-text\">cd</code>: Try <code class=\"language-text\">ls ~/Documents</code>.</p>\n<p>By default, <code class=\"language-text\">ls</code> doesn’t include hidden files and directories in it’s output. A file or directory can be hidden by prefixing its name with a <code class=\"language-text\">.</code>. To see hidden files in a directory, we can specify the <code class=\"language-text\">-a</code> flag as an argument to the <code class=\"language-text\">ls</code> command. Try <code class=\"language-text\">ls -a ~</code> to see both visible and hidden files and directories in your home directory. Multiple flags can be specified at the same time. For example, <code class=\"language-text\">ls -aS1</code> will list the contents of a directory, including hidden files and directories, sorted by size (descending), and print each file or directory on a separate line. Another way of writing this could be <code class=\"language-text\">ls -a -S -1</code>. Flags can often be specified in any order.</p>\n<p><code class=\"language-text\">mkdir</code> Makes a new directory, accepts the directory name as an argument: Try: <code class=\"language-text\">mkdir my_directory</code> (where <em>my</em>directory_ is the name of the directory you’d like to create), then verify that the directory was created: <code class=\"language-text\">ls</code>. Navigate into the new directory with <code class=\"language-text\">cd my_directory</code>.</p>\n<p>You can make several nested directories at once by specifying the <code class=\"language-text\">-p</code> flag and a path as an argument: <code class=\"language-text\">mkdir -p my/deeply/nested/directories</code> would create a structure that looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">my\n  deeply\n    nested\n      directories</code></pre></div>\n<p><code class=\"language-text\">env</code> The shell provides details about the “environment” that are available commands that we run. <code class=\"language-text\">env</code> lists those environment details. Try out the <code class=\"language-text\">env</code> command without any arguments. You’ll probably notice that it prints out a list of lots of text. Each item in this list is called an “environment variable”. The item is actually a key-value pair separated by an <code class=\"language-text\">=</code> character. The token on the left side of the = is the name of the environment variable. It’s a convention to name environment variables using all uppercase characters, but variables can be named using lowercase characters, numbers, or the underscore (<code class=\"language-text\">_</code>) character. A variable cannot start with a number however. The token on the right side of the = is the value of the variable. This can be anything! We reference variables by adding a <code class=\"language-text\">$</code> to their name.</p>\n<p>You’ll probably see an environment variable called <code class=\"language-text\">PATH</code> in the list. This is used by the shell to find the commands we’ve been using! Each command is an executable file somewhere on our filesystem. When we type the command, the shell finds that file and executes it. The <code class=\"language-text\">PATH</code> variable is a colon-delimited list of paths to directories that the shell will use to find an executable file with the same name as the commands we enter. If you list the contents of each of the directories in the <code class=\"language-text\">$PATH</code>, you’ll find all of the commands we’re using plus A LOT more.</p>\n<p>Let’s put some environment variables into practice:</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ echo The current user is $USER and its home directory is located at $HOME\nThe current user is dan and its home directory is located at /Users/dan</code></pre></div>\n<p>We can add a new variable to the environment using the <code class=\"language-text\">export</code> command:</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ export MY_VAR=&quot;My environment variable&quot;\n$ echo $MY_VAR\nMy environment variable</code></pre></div>\n<p><em>Note:</em> We’re including quotes around the environment variable value because it contains whitespace. We use quotes to make sure the shell treats the text between the quotes as a single token.</p>\n<p>Environment variables stay in the environment for the duration of the session. If you were to close your terminal window and open a new window, it would no longer have a value.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ echo $MY_VAR\n\n# In a new session, echo will only print a blank line because $MY_VAR is no\n# longer set</code></pre></div>\n<p><em>Note:</em> In a shell, the <code class=\"language-text\">#</code> character is used to denote a comment. Anything following a <code class=\"language-text\">#</code> on the same line will be ignored by the shell. This can be useful for writing human-friendly notes.</p>\n<p><code class=\"language-text\">open</code> Accepts a path as an argument and uses the operating system’s default application to open the path. For example, <code class=\"language-text\">open my_video.mov</code> might open the video file using Quicktime. <code class=\"language-text\">open index.html</code> would open the html file using the web browser.</p>\n<p><code class=\"language-text\">man</code> Accepts the name of a command as an argument and prints the manual page for the specified command using a program called <code class=\"language-text\">less</code>. The manual page lists a synopsis of what the command does as well as all the flags and arguments accepted by the command. Use the <code class=\"language-text\">q</code> key to quit the less program and return to the command line.</p>\n<p>Let’s add support for opening VSCode from the command line. Open VSCode and press <code class=\"language-text\">cmd+shift+P</code> to open the quick actions bar. Type <code class=\"language-text\">Shell command</code> and select “Install ‘code’ command in PATH”. This will allow us to open VSCode from the command line by typing <code class=\"language-text\">code</code>.</p>","frontmatter":{"title":"Learn Basic Shell Commands","date":"December 08, 2022","description":"The most important shell commands for web application development"}}},"pageContext":{"slug":"/basic-shell-commands/","previous":{"fields":{"slug":"/learn-web-dev/"},"frontmatter":{"title":"Learn Web App Development — \"Syllabus\""}},"next":{"fields":{"slug":"/basic-git-usage/"},"frontmatter":{"title":"Learn Basic Git usage"}}}}}